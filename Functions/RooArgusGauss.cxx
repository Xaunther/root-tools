/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// Your description goes here...

#include "Riostream.h"

#include "Functions/RooArgusGauss.h"
#include "RooAbsReal.h"
#include "RooAbsCategory.h"
#include <math.h>
#include "TMath.h"

// Weights
#include "Functions/gaussian_quadrature_64.h"

//ClassImp(RooArgusGauss)

 RooArgusGauss::RooArgusGauss(const char *name, const char *title,
                        RooAbsReal& _m,
                        RooAbsReal& _m0,
                        RooAbsReal& _c,
                        RooAbsReal& _p,
                        RooAbsReal& _sigma) :
   RooAbsPdf(name,title),
   m("m","m",this,_m),
   m0("m0","m0",this,_m0),
   c("c","c",this,_c),
   p("p","p",this,_p),
   sigma("sigma","sigma",this,_sigma)
 {
 }


 RooArgusGauss::RooArgusGauss(const RooArgusGauss& other, const char* name) :
   RooAbsPdf(other,name),
   m("m",this,other.m),
   m0("m0",this,other.m0),
   c("c",this,other.c),
   p("p",this,other.p),
   sigma("sigma",this,other.sigma)
 {
 }


Double_t RooArgusGauss::argus(Double_t x) const
 {
  Double_t t = x/m0 ;
  if (t >= 1) return 0.0 ;
  Double_t u = 1 - t*t;
  return x*TMath::Power(u,p)*std::exp(c*u) ;
 }


Double_t RooArgusGauss::gauss(Double_t x) const
 {
  return std::exp(-0.5*x*x/(sigma*sigma)) ;
 }


Double_t RooArgusGauss::evaluate() const
 {
   Double_t sum = 0.0 ;
   Double_t z ;
   double* leg_roots = legendre_roots();
   double* quad_weights = quadrature_weights();
   for (int i = 0; i < 64; i++) {
    z = (m0/2.0) * (leg_roots[i]+1) ;
    sum += quad_weights[i] * argus(z) * gauss(m-z) ;
   }
   if ( sum < 1e-8 ) return 0.0 ;
   return sum ;
 }



